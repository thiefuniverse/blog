<!DOCTYPE html>
<html lang="en-us">
<head>
    <title>Thief&#39;s Valley</title>
    <meta charset="utf-8" />
    <meta name="author" content="thief" />
        <meta name="description" content="Welcome to Thief&#39;s Valley!" />
        <meta name="keywords" content="thiefuniverse flythief" />

    <meta name="viewport" content="width=device-width">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link rel="stylesheet" href="/media/stylesheets/styles.css">
    <link rel="stylesheet" href="/media/stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width">
    <style type="text/css"></style>
</head>

<body class="wrapper">
  <header>
    <h1>Something about C++ in Assembly</h1>
<br>
<nav class="main-nav">
  <ul class="keywords">
      <li> <img class="keywords-image" src="/media/img/keywords.png"> Assembly</li>
      <li> <img class="keywords-image" src="/media/img/keywords.png">C++</li>

  </ul>
  <a id="to_home" href="/index.html"><img src="/media/img/to_home.png"><b>Home</b></a>
</nav>

  </header>
  <section>
    


<div id="outline-container-thief" class="outline-2">
<h2 id="org-thief">前言</h2>
<div class="outline-text-2" id="text-org-thief">
<p>
  最近想补习一下操作系统，了解到有许多可以自己实现操作系统的好方法，比如说有JOS或者清华的ucore系统。其实也不是
从头开始实习系统了，不过会参与实现操作系统的重要组成部分，了解到和操作系统底层相关的各种底层知识。其间我自己还补习
了一下汇编方面的知识，看了一本 <a href="http://pacman128.github.io/pcasm/">pcasm book</a>, 了解到关于C++的许多汇编层面的实现原理（有一本 Inside C++ object model
里面实际上也提到了许多）
</p>
</div>
</div>

<div id="outline-container-thief" class="outline-2">
<h2 id="org-thief">C++ 的函数重载</h2>
<div class="outline-text-2" id="text-org-thief">
<p>
  C语言是不支持函数重载的，而C++可以。关键就在于编译器在编译C++的函数的时候，会把它的参数信息也追加作为标识符。比如说
编译器在处理这个函数时:
</p>

<div class="org-src-container">
<pre class="src src-C">void f( int x, int y, double z) ;    // =&gt; 汇编的函数label可能为 _f_Fiid
void f(double x, double y, int z);   // =&gt; 汇编的函数label可能为 _f_Fddi
</pre>
</div>


<p>
之所以说汇编的label『可能』为是由于不同的编译器的实现可能是不一样的。易知对于C语言，汇编生成的label都是f,所以会产生编译错误。
这里给出一个例子:
</p>

<div class="org-src-container">
<pre class="src src-C++">// test_overload_fun.cpp
// for assembly code:   g++ -S test_overload_fun.cpp
#include &lt;iostream&gt;

 int f(int a, int b, double c){
     return a+b;
 }

 int f(double a, double b, int c){
     return c;
 }
 int main (){
     std::cout&lt;&lt; f(3,4,4.5)&lt;&lt;std::endl;
     std::cout&lt;&lt; f(4.6, 3.6,5)&lt;&lt;std::endl;

 }
</pre>
</div>
<p>
使用g++编译得到的汇编代码里可以大致看到两个函数的label名:
<img src="https://thiefuniverse.github.io/resource/img/assembly_overload.png" alt="assembly_overload.png" />
</p>
</div>
</div>
<div id="outline-container-thief" class="outline-2">
<h2 id="org-thief">C++ 的引用</h2>
<div class="outline-text-2" id="text-org-thief">
<p>
从汇编代码可以明显看出来，引用实际本质上就是指针。
</p>

<div class="org-src-container">
<pre class="src src-C++">#include &lt;iostream&gt;

int byref(int &amp; foo)
{
  return foo;
}
int byptr(int * foo)
{
  return *foo;
}

int main(int argc, char **argv) {
  int aFoo = 5; 
std::cout&lt;&lt; byref(aFoo)&lt;&lt;std::endl;

  std::cout&lt;&lt; byptr(&amp;aFoo)&lt;&lt;std::endl;
}
</pre>
</div>

<p>
Mac下汇编得到的两个函数代码分别是:
</p>

<div class="org-src-container">
<pre class="src src-C">__Z5byptrPi:                            ## @_Z5byptrPi
     .cfi_startproc
## BB#0:
     pushq	%rbp
Lcfi3:
     .cfi_def_cfa_offset 16
Lcfi4:
     .cfi_offset %rbp, -16
     movq	%rsp, %rbp
Lcfi5:
     .cfi_def_cfa_register %rbp
     movq	%rdi, -8(%rbp)
     movq	-8(%rbp), %rdi
     movl	(%rdi), %eax
     popq	%rbp
     retq
     .cfi_endproc

     .globl	_main
     .p2align	4, 0x90
</pre>
</div>



<div class="org-src-container">
<pre class="src src-C">__Z5byrefRi:                            ## @_Z5byrefRi
     .cfi_startproc
## BB#0:
     pushq	%rbp
Lcfi0:
     .cfi_def_cfa_offset 16
Lcfi1:
     .cfi_offset %rbp, -16
     movq	%rsp, %rbp
Lcfi2:
     .cfi_def_cfa_register %rbp
     movq	%rdi, -8(%rbp)
     movq	-8(%rbp), %rdi
     movl	(%rdi), %eax
     popq	%rbp
     retq
     .cfi_endproc

     .globl	__Z5byptrPi
     .p2align	4, 0x90
</pre>
</div>

<p>
两个函数的汇编代码可以说完全一样。
</p>
</div>
</div>

<div id="outline-container-thief" class="outline-2">
<h2 id="org-thief">C++ 内联函数</h2>
<div class="outline-text-2" id="text-org-thief">
<p>
我们知道C++的内联函数在编译阶段会直接被替换成具体的函数内语句，这一点从汇编代码上也可以明显看出来。
</p>
</div>
</div>

<div id="outline-container-thief" class="outline-2">
<h2 id="org-thief">C++继承和多态</h2>
<div class="outline-text-2" id="text-org-thief">
<p>
   首先我们要知道，C++的类的成员函数在编译时会默认添加第一个参数，即this指针。这个参数对我们是隐式存在的，
我们在调用某个对象的成员函数时，实际上把对象自身的地址作为this指针传入了成员函数中。（此处说明的只是C++的
一种实现方式，或者说是编译器的一种实现方式）
</p>

<p>
    我们知道C++的多态是通过虚函数来实现的, 含有虚函数的类实例就会存在一个虚函数表指针，指向虚函数的集合。
如果有继承类overwrite某个虚函数，子类的虚函数表会相应地更新。这样的话，即使父类指针指向子类实例，也能通过
已经实现覆盖更新过的虚函数表准确地调用对应的函数。
</p>

<p>
送上一段代码，可以用来测试虚函数表的实际工作过程(测试在ubuntu 16.04下可编译通过并运行).
</p>

<div class="org-src-container">
<pre class="src src-C++">#include &lt;iostream&gt;
using namespace std;

class A{
public:
    virtual void   m1() {
	std::cout&lt;&lt; " A: m1()"&lt;&lt;std::endl;
    }
    virtual void m2(){
	std::cout&lt;&lt;" A: m2()"&lt;&lt;std::endl;
    }
    int ad;
};

class B: public A{
public:
    virtual void m1() {
	std::cout&lt;&lt; " B::m1()"&lt;&lt;std::endl;
    }
    int bd;
};

void print_vtable(A *pa){
    unsigned * p = reinterpret_cast&lt;unsigned*&gt;(pa);
    void **vt = reinterpret_cast&lt;void **&gt; (p[0]);
    std::cout&lt;&lt; std::hex&lt;&lt; "vtable address: "&lt;&lt;vt&lt;&lt;std::endl;

    for(int i=0; i&lt; 2; i++){
	std::cout&lt;&lt; "dword "&lt;&lt;i&lt;&lt;":"&lt;&lt;vt[i]&lt;&lt;std::endl;
   }

    void (*m1func_pointer)(A*);
    m1func_pointer = reinterpret_cast&lt;void (*)(A*)&gt; (vt[0]);
    m1func_pointer(pa);

    void (*m2func_pointer)(A*);
    m2func_pointer = reinterpret_cast&lt;void (*)(A*)&gt; (vt[1]);
    m2func_pointer(pa);

}

int main (){
    A a;
    B b1, b2;
    std::cout&lt;&lt; "a:"&lt;&lt;std::endl;
    print_vtable(&amp;a);

    std::cout&lt;&lt; "b1:"&lt;&lt;std::endl;
    print_vtable(&amp;b1);

    std::cout&lt;&lt; "b2:"&lt;&lt;std::endl;
    print_vtable(&amp;b2);



}
</pre>
</div>

<p>
输出为:
</p>

<div class="org-src-container">
<pre class="src src-C++">a:
vtable address: 0x400f88
dword 0:0x400dc8
dword 1:0x400df4
 A: m1()
 A: m2()
b1:
vtable address: 0x400f68
dword 0:0x400e20
dword 1:0x400df4
 B::m1()
 A: m2()
b2:
vtable address: 0x400f68
dword 0:0x400e20
dword 1:0x400df4
 B::m1()
 A: m2()
</pre>
</div>

<p>
易知继承之后的B类中虚函数表重写了m1的指针。结构示意图如下:
<img src="https://thiefuniverse.github.io/resource/img/polymorphism.png" alt="polymorphism.png" />
</p>

<p>
欢迎评论区交流~~~   :)
</p>
</div>
</div>

    <!-- duoshuo comment box start -->
	<div class="ds-thread" data-thread-key="Something about C++ in Assembly" data-title="Something about C++ in Assembly" data-url="articles/2017/10/something_about_cplusplus_in_assembly"></div>
<!-- duoshuo comment box end -->

<!-- duoshuo comment js code start -->
<script id="dsq-count-scr" src="//thiefuniverse.disqus.com/count.js" async></script>
<!-- duoshuo comment js code end -->

  </section>
  <footer>
  <small><a href="https://github.com/thiefuniverse"><strong>ThankFly</strong></a>'s <a href="/index.html">Personal Blog</a>.</small>
  <br>
  <small>about this page's <a href="https://github.com/thiefuniverse/blog-minimal">generation</a></small>
</footer>
<script src="javascripts/scale.fix.js"></script>
<script src="javascripts/scale.fix.js"></script>
  </body>
</html>
